## 1.关系数据库中，基本关系的性质

* 列是同质的，即同一属性名下的诸属性值是同类型的数据，且必须来自同一个域；
* 不同列的列属性必须有不同的属性名；
* 列的次序无所谓，可以任意交换；
* 任意两个元组不能完全相同；
* 行的次序无所谓，可以任意交换；
* 不允许“表中套表”，即分量必须取原子值，每一个分量必须是不可分的数据项；

参考： [数据库中基本关系的性质（图表举例）](https://blog.csdn.net/dyw_666666/article/details/88842371)；


### 2.count(*)、count(1)、count(列名)有什么区别？

* count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL；
* count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL；
* count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
* 列名为主键，count(列名)会比count(1)快 。
* 列名不为主键，count(1)会比count(列名)快。
* 如果表多个列并且没有主键，则 count(1)的执行效率优于count(*)。
* 如果有主键，则select count(主键)的执行效率是最优的。
* 如果表只有一个字段，则select count(*)最优。


### 3.在INNODB与MYISAM中统计当前数据行，用count(*)有什么区别？

MyISAM对于表的行数做了优化，具体做法是有一个变量存储了表的行数，如果查询条件没有WHERE条件则是查询表中一共有多少条数据，MyISAM可以做到迅速返回，前提条件是没有where语句。InnoDB不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。那么为什么InnoDB没有了这个变量呢？因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。

InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。 如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。

### 4.MySQL查询一定大范围的数据和在Redis中查询一定大范围的数据量，那个更快一点？

redis的查询效率比Mysql查询效率要快；因为Redis的数据是保存在内存中，我们可以直接去内存中读取数据，这样的效率更快一点，而MySql数据是保存在磁盘中，每次查询数据我们都要去磁盘进行IO读取，大大增加了查询时间，同时还会涉及到回表的问题，影响查询效率。

Redis存储的是k-v格式的数据。时间复杂度是O(1),常数阶，而MySQL引擎的底层实现是B+Tree，时间复杂度是O(logn)，对数阶。Redis会比MySQL快一点点。

Redis是单线程的多路复用IO，单线程避免了线程切换的开销，而多路复用IO避免了IO等待的开销，在多核处理器下提高处理器的使用效率可以对数据进行分区，然后每个处理器处理不同的数据。