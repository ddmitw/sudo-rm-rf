## 1.设计模式三大类

设计模式分为三种类型，共23类。

（1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。

（2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

（3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

参考：

1. [设计模式——设计模式三大分类以及六大原则](https://blog.csdn.net/SEU_Calvin/article/details/66994321)；
2. [图解九种常见的设计模式](https://segmentfault.com/a/1190000030850326)；

## 2.设计模式六大原则

### 2.1 单一职责原则

单一职责原则(Single Responsibility Principle)是指，不要让一个类承担过多的职责。避免职责耦合在一起，避免一个职责的变化影响到其他职责。

比如在Activity中存在网络请求的逻辑，导致Activity过于臃肿，导致引起这个Activity变化的原因太多，这样就违反了单一职责原则，不利于后续的版本维护。

最后再来理解一下单一职责的定义——就一个类而言，应该仅有一个引起它变化的原因。

### 2.2 开放封闭原则

在开发过程中，需求的变化如果要通过修改原有的代码来完成，那么就很可能将新的错误引入到旧的代码中。因此才有了开放封闭原则。就是说，需求改变时，我们应该尽量通过拓展的方式、即加入新代码来实现变化。

开放封闭原则（Open Close Principle）的定义——软件中的对象（类、模块、函数等）应该对于拓展是开放的，而对于修改是封闭的

### 2.3 里氏替换原则

里氏代换原则（Liskov Substitution Principle）告诉我们，只要父类出现的地方，子类就可以出现，替换为子类后不会产生任何错误和异常，当然反过来未必适应。

我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，在运行时再确定其子类类型，用子类实例来替换父类实例。里氏替换原则是开闭原则的具体实现手段之一。

里氏替换原则的定义——所有引用基类（父类）的地方必须能透明地使用其子类的对象。

### 2.4 依赖倒置原则

依赖倒置原则在Java中是指接口或抽象类不依赖于实现类，而实现类依赖接口或抽象类。

就是说如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。依赖倒置就是为了**解决耦合**。让程序依赖于抽象。

### 2.5 迪米特原则 

也称为最少知识原则（Demeter Principle），是指一个对象应该对其他对象有最少的了解。

通俗的讲，一个类对自己需要耦合的类应该知道的最少，你内部多么复杂和我没关系，我只对你提供的public方法感兴趣。这样的话，如果一个系统符合迪米特法则，那么当其中某一个类发生修改时，就会尽量少地影响其他模块，降低系统的耦合度，使类与类之间保持松散的耦合关系。

### 2.6 接口隔离原则

接口隔离原则（Interface Segregation Principle）的含义是：建立单一接口而不是建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。单一职责原则注重的是职责，针对的是程序中的实现和细节；而接口隔离原则注重的是对接口依赖的隔离，主要针对抽象。

接口隔离原则的定义：类间的依赖应该建立在最小的接口上。

参考：

1. [设计模式——设计模式三大分类以及六大原则](https://blog.csdn.net/SEU_Calvin/article/details/66994321)；